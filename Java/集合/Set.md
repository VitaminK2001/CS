Set所有子类都不能在添加时指定位置
# HashSet
底层:HashMap
通过hashCode()存取元素
存:
元素的哈希码和数组的长度来计算该元素应该放入的桶的索引
`int bucketIndex = (hash & 0x7FFFFFFF) % table.length;`
`hash` 是元素的哈希码，`table.length` 是 `HashMap` 内部数组的长度。
`(hash & 0x7FFFFFFF)` 是为了确保结果为非负数，因为哈希码可能是负数。

若hashCode()相等,但是equals()不等,则哈希冲突,采用链表法或者红黑树解决冲突
>  链表法（JDK < 8 && JDK 8 中链表长度小于 8 时）：当发生哈希冲突时，新元素会被添加到该桶对应的链表中。在查找元素时，需要遍历链表，依次比较元素的`equals()`方法来确定是否是要查找的元素。

>  红黑树法（JDK 8 中链表长度 >= 8 且数组长度(桶的数量) >= 64 时）：链表会转换为红黑树，查找、插入和删除操作的时间复杂度为$O(log_2n)$，比链表的$O(n)$效率更高。当树中的元素数量减少到一定阈值（默认为 6）时，红黑树会转换回链表。


如何判断同一个元素
若两个元素[[equals()]]相等,则是同一个元素

插入时间复杂度:
- 理想O(1),若所有元素都在一个桶中,
- 若使用链表存储,退化为O(n) (极低概率)
- 若使用红黑树存储,退化为O(logn)(极低概率)
遍历时间复杂度:
- 本质:对底层`HashMap`中的所有键进行遍历
- HashMap内部维护一个数组,每个元素是链表或红黑树的头节点
	- 首先遍历每个桶,数组长度为m
	- 然后遍历桶中的元素,元素总数为n
	- 所以遍历时间复杂度为O(n)

Set中用迭代器遍历还是用for循环遍历,for循环遍历的底层是通过迭代器实现的吗?通过迭代器遍历需要注意的点有哪些?

# LinkedHashSet
底层: LinkedHashMap,维护插入顺序

插入过程和HashSet一样,
但是LinkHashSet的遍历是沿着底层LinkedHashMap维护的双向链表中的每个节点访问
由于 `LinkedHashSet` 中存储了 n 个元素，所以遍历操作需要访问 n 个节点
所以遍历时间复杂度为O(n)

# TreeSet
底层: 红黑树
存储基础对象类型,自动排序(Integer,String等)
存储自定义数据类型,要实现Comparable接口,重写compareTo()




死锁和饥饿
饿死进程等待的是会释放但是不会分配给自己的资源
死锁进程等待的是不会释放的资源

解除死锁的三种方法
剥夺资源：抢其他进程资源
撤销进程：直到有足够资源分配给其他进程解除死锁状态
进程回退：进程自愿释放资源而不是被剥夺

死锁检测
找出那些对==各类资源请求数目==均小于系统现有的==各类可利用资源数目==的进程。这样的进程可以获得它们所需要的全部资源并运行结束，
当运行结束后，它们会释放所占有的全部资源，而使可用资源数目增加，将这样的进程加入到可运行结束的进程序列中，然后对剩下的进程再进行上述考查。
如果一组进程中有几个不属于该序列，那么它们会发生死锁。

死锁预防——破坏死锁的四个必要条件之一
互斥条件         允许进程同时访问资源
不剥夺条件       若新资源请求不能立即得到满足，则必须释放已有资源
请求与保持条件   运行前一次性申请所需全部资源
环路等待条件     只要进程提出请求资源 Ri，则在以后的请求中只能请求排在Ri后面的资源(i为资源编号)，不能再请求编号排在Ri前面的资源。 对资源请求做了这种限制后，系统中不会再出现几个进程对资源的请求形成环路的情况。

# 经典同步问题
## 生产者消费者
共享一个有界缓冲区，一个说明空缓冲区数目，用empty表示，初值为有界缓冲区大小；另一个说明满缓冲区数目，用full表示，初值为0
还需要设置一个互斥信号变量，初值为1，让多个消费者和生产者互斥访问缓冲池
```c++
//满缓冲区数目 /空缓冲区数目
Semaphore fuil=0; Semaphore empty=n; 
//对有界缓冲区进行操作的互斥信号量
Semaphore mutex=1; 

Producer() {

	while(true) {
		Produce an item put in nextp; //nextp为临时缓冲区
		
		P(emapty);  //申请一个空缓冲区
		P(mutex);  //申请使用缓冲池
		将产品放入缓冲池 
		V(mutex); //缓冲池使用完毕，释放互斥信号量 
		V(full);  //增加一个空缓冲区
	}
}

Consumer () {
	while(true){
		P(full);  //申请一个满缓冲区 
		P(mutex); //申请使用缓冲池
		
		取出产品 
		V(mutex); //缓冲池使用完毕，释放互斥信号量 
		V(empty); //增加一个满缓冲区
		Consumer the item in nextc; //消费掉产品
	}
}
```
P操作的顺序不能颠倒（先对资源信号量进行P操作，再对互斥信号量进行P操作，防止始终掌握缓冲池访问权而无法释放的情况发生，即P(mutex)成功但是P(full)失败），但是V的顺序无所谓

如果有多个同类进程（使用一个记录型信号量的进程），就一定需要互斥信号量，若同类进程只有一个，则记录型信号量即可完成同步。
## 读者写者问题
可以有很多个读者同时读，但是写者必须互斥访问
### 读者优先算法
读者在读的时候，可以有新的读者到来，但是写者不能在有读者的时候写







# 概念

## 守护进程
- 后台服务程序
- 生存周期长，系统装入时启动，系统关闭时终止
- 等待客户端程序与之通信，没有控制端，无法与前台的用户交互
- 周期性的执行某种特殊的任务或者等待某些特别的事件
- 很多的系统服务通过守护进程完成，比如的网络服务程序，可以在完成创建套接口，绑定套接口，设置套接口为监听模式后，变成守护进程进入后台执行而不占用控制终端，这是网络服务程序的常用模式
- 守护进程名字常常以'd'结尾
- 独立于控制终端

**总结**
守护进程是后台运行的、系统启动时就存在的、不予任何终端关联的，用于处理一些系统级别任务的特殊进程。
**实现思路**
实现一个守护进程，其实就是将普通进程按照上述特性改造为守护进程的过程。

## #进程、进程组、会话组

进程都有父进程，父进程也有父进程，这就形成了一个以init进程为根的家族树。
除此以外，进程还有其他层次关系：进程、进程组和会话。
进程组和会话在进程之间形成了两级的层次：
进程组是一组相关进程的集合，会话是一组相关进程组的集合。

一个进程会有如下ID：
PID：进程的唯一标识。对于多线程的进程而言，所有线程调用getpid函数会返回相同的值。
PGID：进程组ID。每个进程都会有进程组ID，表示该进程所属的进程组。默认情况下新创建的进程会继承父进程的进程组ID。
SID：会话ID。每个进程也都有会话ID。默认情况下，新创建的进程会继承父进程的会话ID。
新进程默认继承父进程的进程组ID和会话ID，如果都是默认情况的话，那么追根溯源可知，所有的进程应该有共同的进程组ID和会话ID。
但是调用ps axjf可以看到，实际情况并非如此，系统中存在很多不同的会话，每个会话下也有不同的进程组。
这是因为系统有改变和设置进程组ID和会话ID的函数接口。

当有新的用户登录Linux时，登录进程会为这个用户创建一个会话。用户的登录shell就是会话的首进程。会话的首进程ID会作为整个会话的ID。
**会话是一个或多个进程组的集合，囊括了登录用户的所有活动。**
在登录shell时，用户可能会使用管道，让多个进程互相配合完成一项工作，这一组进程属于同一个进程组。
通常，会话开始于用户登录，终止于用户退出，期间的所有进程都属于这个会话。
一个会话：
一个前台进程组，多个后台进程组（也可以一个），控制终端可有可无。
	前台进程组
		前台进程组的ID = 控制终端进程组ID
		可以获得用户在终端的输入
		可以向终端设备进行读写操作
	后台进程组
		只能向终端设备进行写操作
		除了会话首进程和前台进程组以外的所有进程都是后台进程组
		
		![[截屏2022-11-25 19.10.21.png]]


控制终端的本质
	一个设备文件，由会话首进程打开，由终端驱动程序控制
	控制终端接收用户从终端的输入
	将输入内容传给与该终端相关联的前台进程

一个控制终端
	对应一个会话的首进程（shell进程），终端断开后收到相应的信号，（挂起信号），进行相应清理工作
	控制着一组前台进程组
	多组后台进程组
	这些进程组属于同一个会话


# 创建步骤

1. fork创建子进程 父进程eixt()退出
	- 因为守护进程是脱离控制终端的，完成这一步后，就会在终端中造成已经运行完的假象，之后所有的工作在子进程中完成
	- 因为父进程**先于**子进程退出，子进程变成**孤儿进程**，由init进程收养

2. 在子进程中调用setsid()创建新会话
	- fork函数让子进程全盘拷贝了父进程的会话期，进程组，控制终端等，虽然父进程退出，但是会话期，进程组，控制终端没有改变，这不是真正意义上的独立。
	- setsid()创建一个新会话，**调用进程**担任新会话的首进程
		- 使当前进程脱离原**会话**的控制
		- 使当前进程脱离原**进程组**的控制
		- 使当前进程脱离原**控制终端**的控制

3. 再次fork一个子进程，父进程exit退出
	- 现在子进程已经成为无终端的会话组长
	- 但是它可以重新打开一个控制终端，这是我们不想要的
	- 可以通过fork一个子进程(子进程$^2$)，使原先的子进程不再是会话首进程，**导致**该进程将不能重新打开控制终端
	- 退出原先子进程

4. 在子进程中调用chdir()让更目录"/"成为子进程的工作目录
	- 使用fork创建的子进程继承了父进程的当前工作目录，这是我们不想要的。
	- 通常的做法是让"/"成为守护进程的当前工作目录如果有特殊需要，也可以把当前工作目录换成其他的路径如/tmp
```ad-warning
因为当前的目录所在的文件系统(如"/mnt/usb")是不能卸载的，对以后的使用会造成麻烦，比如系统需要进入单用户模式的时候
```

5. 在子进程中调用umask()重设文件权限掩码为0
	- 文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限，可读与可执行权限都变成7。
	- 由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给孩子进程使用文件带来了诸多的麻烦。因此把文件权限掩码重设为0即清除掩码（权限为777）。
	- 这样大大增强守护进程的灵活性。通常使用方法是umask(0)。

6. 在子进程中close()不需要的文件描述符
	- 同文件权限码一样，由fork函数新建的子进程会从父进程那里继承一些已经打开了的文件
	- 这些被打开的文件可能永远不会被守护进程读写
	- 但他们一样消耗资源，可能导致所在的文件系统无法卸下。
	- 其实在第二步之后，守护进程中常规方法输出的字符也不可能在终端上显示出来。所以文件描述符为0,1,2的三个文件（输入输出报错）已经失去意义，也应被关闭。
```ad-important
for (i = 0; i < MAXFILE; ++i){
	close(i);
}
```

7. 守护进程退出处理
	- 当用户需要外部停止守护进程运行时，往往会使用kill命令停止该守护进程。
	- 所以，守护进程中需要编码来实现kill发出的signal信号处理，达到进程正常退出。

#### 整体流程
![[Pasted image 20221125193606.png]]

简单代码
```cpp
pid = fork();
if(pid == 0){
  setsid(); // 保证该子进程一定不是组长进程，保证 setsid() 调用成功.
  pid = fork();
  if(pid == 0){
    //执行应用程序，此时既不是会话首进程也不是组长进程，再也不能打开控制终端.  
  }
}
```

通过
`ps -ef | grep 'daemon'`
ps命令将某个进程显示出来
grep命令是查找
中间的|功能是把上一条命令的输出，作为下一条命令的参数
PS是LINUX下最常用的也是非常强大的进程查看命令
grep命令是查找，是一种强大的文本搜索工具，它能正则表达式搜索文本，并把匹配的行打印出来。

发现执行前后多看到一个进程
![[截屏2022-11-25 19.38.22.png]]
![[截屏2022-11-25 19.38.53.png]]

退出守护进程
![[截屏2022-11-25 19.39.51.png]]

```c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <syslog.h>
#include <unistd.h>
int daemon_init(void)
{
  pid_t pid;
  if ((pid = fork()) < 0)
    return (-1);
  else if (pid != 0)
    exit(0); /* parent exit */
 
  /* child continues */
  setsid();   /* become session leader */
  chdir("/"); /* change working directory */
  umask(0);   /* clear file mode creation mask */
  close(0);   /* close stdin */
  close(1);   /* close stdout */
  close(2);   /* close stderr */
  return (0);
}
 
void sig_term(int signo) {
  if (signo == SIGTERM)
  /* catched signal sent by kill(1) command */
  {
    syslog(LOG_INFO, "program terminated.");
    closelog();
    exit(0);
  }
}
 
int main(void) {
  if (daemon_init() == -1) {
    printf("can't fork self\n");
    exit(0);
  }
 
  openlog("daemontest", LOG_PID, LOG_USER);
  syslog(LOG_INFO, "program started.");
  signal(SIGTERM, sig_term); /* arrange to catch the signal */
 
  while (1) {
    sleep(1); /* put your main program here */
  }
 
  return (0);
}
```

## 运行结果

![[截屏2022-11-25 14.20.25.png]]

![[截屏2022-11-25 14.26.28.png]]

![[截屏2022-11-25 14.21.55.png]]

关于各行代码的解释

程序和进程：

> 1、程序：程序是静止的，程序就是磁盘上的一个文件。
> 
> 2、进程：进程是一个正在执行的程序的实例。
> 
> 3、进程是动态的。
> 
> 4、一旦程序被操作系统加载进内存了，那么这程序就成为了进程。

PID和PPID：

> 1、PID（process ID）：进程识别号，也就是进程标识符
> 
> 	PID是程序被操作系统加载到内存成为进程后动态分配的资源。
> 
> 	每次程序执行的时候，操作系统都会重新加载，PID在每次加载的时候都是不同的。

> 2、PPID（parent process ID）：PPID是进程的父进程号。

> 3、PID和PPID都是非零的整数。

> 4、PID是唯一的，一个PID只标识一个进程，每个进程只有唯一一个PID

> 5、一个进程创建的另一个新进程称为子进程。相反地，创建子进程的进程称为父进程。

> 6、对于一个普通的用户进程，它的父进程就是执行它的Shell，对于Linux而言，Shell就是bash。

> 7、bash所在的目录：[negivup@localhost bin]$ cd /bin | ls bash

> 8、UID 用户身份证明(User Identification)的缩写。UID用户在注册后，系统会自动的给你一个UID的数值。意思就是给这名用户编个号。

kill 之后发现这个进程没有了

![[截屏2022-11-25 14.35.27.png]]

![[截屏2022-11-25 14.35.17.png]]


完整的存储系统——
主存储器、高速缓冲存储器、辅助存储器

# 存储器分类
半导体存储器——
RAM（随机存储器）
	SRAM（常做高速缓冲存储器）
	DRAM（常做主存）
ROM（只读存储器）
	名称中有E可擦除
	ROM只能随机取，不能随机存，但是有时候也叫做随机存储器

磁表面存储器——
磁盘

光存储器——
光盘

串行访问存储器——
按照物理位置的先后顺序进行访问
顺序存取存储器（磁带）
直接存取存储器（磁盘）
	磁盘寻找数据，先寻道（随机访问），再磁道旋转，顺序寻找需要的信息，这种前段直接访问后段串行访问的存储器成为直接存取存储器

# 存储系统层次结构
==主存和缓存==之间交换信息由硬件自动完成，对程序员透明，主存和辅存之间交换信息由硬件和操作系统共同完成。

# 半导体随机存储器
![[Pasted image 20230906195558.png|500]]
## DRAM
电容存储电荷
补充知识点：
	读写时间表示进行一次存储器==读写操作的时间==
	读写周期表示两次连续读写操作的==最小时间间隔==
### 存储器的刷新
刷新：读出后按原样写入，如果题目中没有特别说明读操作和写操作一起进行，则刷新一行需要的时间还是一个存储周期而不是两个周期
#### 集中刷新
电容电荷只能维持2ms，2ms内对存储矩阵的每一行找一个时间段集中刷新
这段刷新时间叫做死时间
#### 分散刷新
存储周期 变成了 读/写周期 + 刷新一行的时间 = 读/写周期 * 2
#### 异步刷新
在2ms内每隔一段时间刷新一行，2ms后刷新所有行
128行 在2ms内刷新一遍，即每隔15.6μs(2000μs/128~15.6μs)刷新一行
## ROM 和 闪存
...
## 主存储器与CPU的链接
...
# 高速缓冲存储器
主存和Cache映射的前提：每块的大小相同
主存的地址格式：
高m位表示主存的块地址，低b位表示块内的字或字节数
Cache的地址格式：
高c位表示Cache的块号，低b位表示块内的字或字节数
Cache的块数远小于主存的块数
![[Pasted image 20230906203044.png]]
## Cache和主存映射方式
### 直接映射
cache 8
主存 256
主存可以将8块看做一个轮回，一共有32个轮回
主存每个轮回中第i块<span style="background:rgba(5, 117, 197, 0.2)">只能映射</span>到Cache的第i块
优点：只需要通过主存的某些位便可判断是否在Cache中
缺点：
1. 不够灵活，Cache空闲空间得不到利用
2. 冲突概率高（抖动），频繁的交换
![[Pasted image 20230907110506.png|500]]
### 全相联映射
主存的每一个字块可以映射到Cache的任意一块，<span style="background:rgba(255, 183, 139, 0.55)">“有位置就可以坐”</span>
![[Pasted image 20230907110446.png|500]]
### 组相联映射
将组相联映射中的==一组看做==直接映射的==一块==，组内全相联
![[Pasted image 20230907110412.png|500]]
![[Pasted image 20230907111117.png|700]]
## Cache主存块替换算法
对于直接映射，一个主存块只能存放在特定的Cache块，所以==只能==把这个位置的主存块换出
对于其他两种映射，需要考虑从Cache中换出哪一块
理想的替换算法是把未来很少用的，或者很久才用到的数据块替换出来，实际很难
### 先进先出FIFO
选最早调入的Cache的字块换出，没有考虑局部性原理
### LRU近期最少使用
记录每个块最近一次的使用时间，替换近期用的最少得字块，平均命中率高于FIFO
## Cache写操作策略
Cache的内容是主存部分内容的副本
CPU对Cache的写入会导致Cache的内容和主存不一致，如何保持一致？
### 写回法
当CPU写Cache命中时，只修改Cache的内容，不立即写入主存，只有此行被换出时才写入主存
（这种方式减少访问主存的次数，同时需要对每行记录修改位，这样才知道是否被修改过）
如果没有写命中，CPU在主存中找到包含次字的数据块==复制到Cache==进行修改，等从Cache换出后再复制到主存
### 全写法
写Cache命中时，Cache与主存同时发生写修改，较好的保持了Cache和主存内容的一致性
写Cache未命中时，CPU直接在主存中修改，可以复制或不复制到Cache中
### 写一次法
仅仅是第一次写命中时要写回主存
# 虚拟存储器
建立在主存-辅存结构上，允许使用比主存大得多的空间，每次访问需要进行虚实地址变换
虚拟存储器和Cache==都是基于程序局部性原理==，把程序中最近常用的部分驻留在高速的存储器中;一旦这部分程序不再常用，把它们送回到低速存储器中。

页式虚拟存储器就是将其基本单位划分为页，且将主存的物理空间划分为与虚拟存储器等长的页。划分的页称为页面，主存的页称为实页，虚拟存储器的页称为虚页。
系统基本信息的传送单位是定长的页，需要通过==地址变换机构实现访存==过程，当访问页面不在主存时，通过页面置换算法将需要的页面调入主存。
优点∶由于页面的起点、终点地址是固定的，因此页表简单，调入方便，主存空间浪费小。 缺点∶由于页面不是逻辑上的独立实体，因此处理、保护和共享都不如段式虚拟存储器方便。

段式虚拟存储器是一种将主存按段分配的存储管理方式，各段的长度因程序而异。段是利用程序的模块化性质，按照程序的逻辑结构划分成的多个相对独立部分。系统的基本信息传送单位为段，并通过地址变换机构实现访存过程。 
优点∶段的分界与程序的自然分界相对应; 段的逻辑独立性使它易于编译、管理、修改和保护，也便于多道程序共享;某些类型的段(堆栈、队列)具有动态可变长度，允许自由调度以便有效利用主存空间。 
缺点∶段的长度各不相同，段的起点和终点不定，给主存空间的分配带来麻烦，而且容易在段间留下许多空余的不易利用的零碎存储空间，造成浪费。



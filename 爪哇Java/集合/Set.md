> [!faq] Set的实现类都不能指定添加的位置吗?为什么
> `Set` 接口的常见实现类如`HashSet`、`LinkedHashSet` 和 `TreeSet` 都不能指定添加元素的位置
> 因为设计的初衷是表示一个不包含重复元素的集合，它更关注元素的唯一性，而不是元素的顺序或位置。
> 

# HashSet

>[!faq]- 底层是如何计算元素的哈希码的
>  元素的哈希码是通过调用元素对象的 `hashCode()` 方法来获取的
>  `hashCode()` 方法是 `Object` 类的一个方法，所有 Java 类都继承了该方法。
> 
>  如果自定义类没有重写 `hashCode()` 方法，那么将使用 `Object` 类提供的默认实现，该实现通常返回对象的内存地址的一个整数表示。
> 
>  为了保证 `HashSet` 的性能和正确性，通常需要在自定义类中重写 `hashCode()` 方法，并且要遵循以下规则
>  1. 如果两个对象通过 `equals()` 方法比较相等，那么它们的 `hashCode()` 方法返回值必须相同。
>  2. 如果两个对象的 `hashCode()` 方法返回值相同，它们不一定通过 `equals()` 方法比较相等。

>[!faq]- 怎么根据哈希码决定要放入的桶的
>  
>  底层的 `HashMap` 内部维护了一个数组，数组的每个元素被称为一个桶（bucket）。
>  当要添加一个元素时，会根据元素的哈希码和数组的长度来计算该元素应该放入的桶的索引。
>  具体计算方式:
>  `int bucketIndex = (hash & 0x7FFFFFFF) % table.length;`
>  `hash` 是元素的哈希码，`table.length` 是 `HashMap` 内部数组的长度。`(hash & 0x7FFFFFFF)` 是为了确保结果为非负数，因为哈希码可能是负数。

>[!faq]- 如果一个桶中已经有其他的元素怎么办?
>  采用链表法或者红黑树解决冲突
>  链表法（JDK 8 之前及 JDK 8 中链表长度**小于 8** 时）：当发生哈希冲突时，新元素会被添加到该桶对应的链表中。在查找元素时，需要遍历链表，依次比较元素的 `equals()` 方法来确定是否是要查找的元素。
>  红黑树法（JDK 8 中链表长度大于等于 8 且数组长度大于等于 64 时）：为了提高查找效率，当链表长度达到一定阈值（默认为 8）且数组长度达到 64 时，链表会转换为红黑树。红黑树是一种自平衡的二叉搜索树，查找、插入和删除操作的时间复杂度为$O(logn)$，比链表的$O(n)$效率更高。当树中的元素数量减少到一定阈值（默认为 6）时，红黑树会转换回链表。



Set中用迭代器遍历还是用for循环遍历,for循环遍历的底层是通过迭代器实现的吗?通过迭代器遍历需要注意的点有哪些?

# LinkedHashSet

底层: 哈希表+链表,保留元素插入顺序

添加和遍历的时间复杂度是?



# TreeSet

底层: 红黑树,对元素自然排序

给出创建TreeSet时提供Comparator进行排序的代码

给出元素实现Comparable接口的代码






# 属性集闭包
属性A能够函数决定那些属性，哪些属性就在A的属性集闭包中
	这是充分必要条件

## 求X属性闭包的算法
1. 一开始X属性集闭包就是X本身
2. 已知的X属性集闭包V，V函数决定W，则W中的属性可以加入到属性集闭包中
3. 如果属性集闭包$^{i+1}$ = 属性集闭包$^{i}$ 就结束
总结
	已知的集合能够决定其他的集合，则增加其他的，直到增加结束
![[截屏2022-11-28 17.09.38.png]]
![[截屏2022-11-28 19.54.47.png]]

一个关系模式的函数依赖集可能有很多


## 最小函数依赖集
### 要求F
1. 每一个函数依赖的右部都是单个属性（右部最简单）
2. 没有一个冗余的函数依赖
	1. 在函数依赖集合中去掉任意一个函数依赖，都与原来不等价
3. 左部最简单
	1. 如果有一个函数依赖X函数决定A
		1. 如果有一个属性Z是X的子集，Z函数决定A，则{F - {X -> A}} ∪ {Z -> A}不与F等价
	2. 总结：左边没有冗余的属性
		1. 左边的任意一个属性都不是多余的
			1. 不可能存在有真子集决定别人的情况
		2. 将这个属性去掉，仍然不改变函数的依赖关系

![[截屏2022-11-28 17.17.58.png]]
1. 右部最简单（**分解**）
2. 去掉冗余函数依赖
	1. C决定A 则CE决定A是没有意义的
		1. 因为C + 任意集合都能决定A
	2. 从C→A、CG→D、ACD→H推出CG→H
		1. 这是从已知的依赖中可以推出的依赖是冗余的
3. 将左部冗余的属性去掉
	1. 由于C→A, ACD→H中A是冗余属性

## 候选关键字的求解方法
L : 仅在函数依赖左边出现的属性
R : 仅右边
LR : 左右都出现
NLR : 左右都不出现
### 求候选关键字的规则
1. NLR 左右两边都不出现的属性集是候选码
	1. 没有出现，谁也无法决定它，只能自己决定自己
2. NR 不在右边出现的属性集是候选码
3. L 只在左边出现的属性集是候选码
4. 根据候选码的定义判断（属性或属性组能够唯一标识元组）
第四条作为检验使用，检验1~3所有属性构成的集合是否是候选码
![[截屏2022-11-28 20.07.08.png]]
注意第四点，
1. 若前三点添加求出来的属性组中存在真子集可以唯一标识元组，
	1. 则这个真子集才是候选码，
2. 如果连这个属性组都不能唯一标识元组，
	1. 则这个属性组不是候选码

